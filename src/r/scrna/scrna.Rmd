
---
title: "TCSL154 scRNA Analysis"
output:
  html_document:
    df_print: paged
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = here::here('..','html'))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(Seurat)
library(patchwork)
```

```{r load_data}
# Load the PBMC dataset
scrna.data <- Read10X(data.dir = here::here(
    '..','..','scrnaseq_tcsl154',
    'cellranger','outs','raw_feature_bc_matrix'))

#rna features
scrna <- CreateSeuratObject(
    counts = scrna.data$`Gene Expression`, 
    project = "tcsl154", 
    min.cells = 3,
    min.features = 200)

rm('scrna.data')
```

## RNA QC metrics

```{r rna_qc}
VlnPlot(scrna, 
  pt.size=F, 
  features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

plot1 <- FeatureScatter(
  scrna, feature1 = "nCount_RNA", feature2 = "percent.mt")

plot2 <- FeatureScatter(
  scrna, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

plot1 + plot2

scrna <- subset(
  scrna, 
  subset = nFeature_RNA > 1000 & nFeature_RNA < 7000 & percent.mt < 15)
```

## ADT QC Metrics and subsetting

```{r adt_qc}

hto_rows <- paste('Hashtag',1:12,sep='_')
adt_rows <- setdiff(rownames(scrna.data$`Antibody Capture`), hto_rows)

#adt features
scrna[['ADT']] <- CreateAssayObject(
    counts = scrna.data$`Antibody Capture`[adt_rows, colnames(scrna)])
```

## HTO QC Metrics, subsetting, clustering

```{r hto}
scrna[['HTO']] <- CreateAssayObject(
  counts = scrna.data$`Antibody Capture`[hto_rows, colnames(scrna)])

scrna <- NormalizeData(scrna, assay = "HTO", normalization.method = "CLR")

scrna <- DoubleHTODemux(scrna)

gc()
hto_subset <- subset(scrna, cells=sample(Cells(scrna), 10000))


hto.dist.mtx <- as.matrix(parDist(t(
  GetAssayData(object = hto_subset, assay = "HTO"))))

hto_subset <- RunTSNE(hto_subset, 
  distance.matrix = hto.dist.mtx,
  perplexity = 100)

DimPlot(hto_subset)
```
## Multiple HTO Assignments
```{r}
DoubleHTODemux <- function (object, assay = "HTO", positive.quantile = 0.99, init = NULL, 
    nstarts = 100, kfunc = "clara", nsamples = 100, seed = 42, 
    verbose = TRUE) 
{
    
    MaxN <- function(x, N = 2){
      len <- length(x)
      if (N > len) {
        warning('N greater than length(x).  Setting N=length(x)')
        N <- length(x)
      }
      sort(x, partial = len - N + 1)[len - N + 1]
    }
    
    whichpart <- function(x, n=30) {
      nx <- length(x)
      p <- nx-n
      xp <- sort(x, partial=p)[p]
      which(x > xp)[1]
    }
  
    if (!is.null(x = seed)) {
        set.seed(seed = seed)
    }
    ncenters = nrow(x = data) + 1
    data <- GetAssayData(object = object, assay = assay)
    counts <- GetAssayData(object = object, assay = assay, slot = "counts")[, 
        colnames(x = object)]
    counts <- as.matrix(x = counts)
    init.clusters <- clara(x = t(x = GetAssayData(object = object, 
        assay = assay)), k = ncenters, samples = nsamples)
    Idents(object = object, cells = names(x = init.clusters$clustering), 
        drop = TRUE) <- init.clusters$clustering
    average.expression <- AverageExpression(object = object, 
        assays = assay, verbose = FALSE)[[assay]]
    if (sum(average.expression == 0) > 0) {
        stop("Cells with zero counts exist as a cluster.")
    }
    
    discrete <- GetAssayData(object = object, assay = assay)
    discrete[discrete > 0] <- 0
    for (iter in rownames(x = data)) {
        values <- counts[iter, colnames(object)]
        values.use <- values[WhichCells(
          object = object, 
          idents = levels(x = Idents(object = object))[[
            which.min(x = average.expression[iter, ])]])]
        fit <- suppressWarnings(expr = fitdist(data = values.use, 
            distr = "nbinom"))
        cutoff <- as.numeric(x = quantile(
          x = fit, probs = positive.quantile)$quantiles[1])
        discrete[iter, names(x = which(x = values > cutoff))] <- 1
        if (verbose) {
            message(paste0("Cutoff for ", iter, " : ", cutoff, 
                " reads"))
        }
    }
    
    npositive <- colSums(x = discrete)
    classification.global <- npositive
    classification.global[npositive == 0] <- "Negative"
    classification.global[npositive == 1] <- "Singlet"
    classification.global[npositive == 2] <- "Doublet"
    classification.global[npositive == 3] <- "Triplet"
    donor.id = rownames(x = data)
    
    hash.max <- apply(X = data, MARGIN = 2, FUN = max)
    hash.maxID <- apply(X = data, MARGIN = 2, FUN = which.max)
    hash.second <- apply(X = data, MARGIN = 2, FUN = MaxN, N = 2)
    hash.secondID <- apply(X = data, MARGIN = 2, FUN = whichpart, n = 2)
    hash.third <- apply(X = data, MARGIN = 2, FUN = MaxN, N = 3)
    hash.thirdID <- apply(X = data, MARGIN = 2, FUN = whichpart, n = 3)

    hash.maxID <- as.character(x = donor.id[sapply(X = 1:ncol(x = data), 
        FUN = function(x) {
            return(which(x = data[, x] == hash.max[x])[1])
        })])
    
    hash.secondID <- as.character(x = donor.id[sapply(X = 1:ncol(x = data), 
        FUN = function(x) {
            return(which(x = data[, x] == hash.second[x])[1])
        })])
    
    hash.margin <- hash.second - hash.third
    hash.mean.margin <- mean(c(hash.max, hash.second)) - hash.third
    
    doublet_id <- sapply(X = 1:length(x = hash.maxID), FUN = function(x) {
      return(paste(
        sort(c(
          as.numeric(gsub('Hashtag-','',hash.maxID[x])),
          as.numeric(gsub('Hashtag-','',hash.secondID[x])))),
        collapse = "_"))})

    classification <- classification.global
    
    classification[classification.global == "Negative"] <- "Negative"
    classification[classification.global == "Singlet"] <- gsub(
      'Hashtag-','', hash.maxID[which(x = classification.global == "Singlet")])
    classification[classification.global == "Doublet"] <- doublet_id[
      which(x = classification.global == "Doublet")]
    classification[classification.global == "Triplet"] <- paste(
      doublet_id[which(x = classification.global ==  "Triplet")],
        gsub('Hashtag-','',
          hash.thirdID[which(x = classification.global ==  "Triplet")]),
        sep='+')
        
    classification.metadata <- data.frame(hash.maxID, hash.secondID, 
        hash.margin, hash.mean.margin, classification, classification.global)
    
    colnames(x = classification.metadata) <- paste(assay, c("maxID", 
        "secondID", "margin", "mean_margin", "classification", 
        "classification.global"), 
        sep = "_")
    
    object <- AddMetaData(object = object, metadata = classification.metadata)
    Idents(object) <- paste0(assay, "_classification")
    
    triplets <- rownames(x = object[[]])[which(object[[paste0(assay, 
        "_classification.global")]] == "Triplet")]
    singlets <- rownames(x = object[[]])[which(object[[paste0(assay, 
        "_classification.global")]] == "Singlet")]
    
    Idents(object = object, cells = singlets) <- "Singlets"
    Idents(object = object, cells = triplets) <- "Triplets"
    object$hash.ID <- Idents(object = object)
    return(object)
}
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

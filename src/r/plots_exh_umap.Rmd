---
title: "Differentiation Plots for Arrayed Screens"
output:
  html_document:
    df_print: paged
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = here::here('..','html'))})
---

# Load packages and umap functions 
```{r setup}
library(ggplot2)
library(data.table)
library(scales)
library(RColorBrewer)
library(reticulate)
library(uwot)
library(gridExtra)
library(spatstat)
library(ggdendro)
library(cowplot)
library(tidyverse)
library(grid)
library(gridExtra) # add to AWS
library(cowplot) # add to AWS
library(slingshot) # add to AWS
library(viridis) # add to AWS
library(reshape2)
library(RColorBrewer)
library(ggrepel)

source('umap.R')

use_condaenv(condaenv = 'r-reticulate', required = TRUE)
```

# Load data
```{r}
data_dir <- here::here('..','data')
load(file.path(data_dir, 'exh.sampled.Rdata'))
exh_dt <- fread(file.path(data_dir, 'exh.sampled.csv.gz'))

censor_negative_min = -1500
redo_umap_clustering = F
redo_umap_param_search = F

#only redo param search if doing clustering also:
redo_umap_param_search = redo_umap_param_search && redo_umap_clustering

# map day 0 to both plus and minus
map_day_0 <- function(df) {
  return(rbind(
    df[k562!='none'], #gets all cd19+-
    #df[rep(keep_none, .N) & k562=='none' & day > 0], 
    df[k562=='none' & day == 0][, k562 := 'cd19+'], #none and day 0, assign as 19+
    df[k562=='none' & day == 0][, k562 := 'cd19-'], #none and day 0, assign as 19-
    df[car =='untrans' & day != 0][, k562 := 'cd19+'], #add back untrans
    df[car =='untrans' & day != 0][, k562 := 'cd19-']
  ))
}

censor_negative_min = -1500
redo_umap_clustering = F
redo_umap_param_search = F

```

# UMAP

For now, skip straight to high dimensional plotting.

# Filter Data
```{r}
#filter diff_dt by cd4/8 type, cd19+ (map day 0), donor == 1 or 2

#cd4, cd19+, donor 
exh_dt_cd4 <- exh_dt %>% map_day_0() %>% filter(t_type == 'cd4', k562=='cd19+')

#cd8, cd19+, donor
exh_dt_cd8 <- exh_dt %>% map_day_0() %>% filter(t_type == 'cd8', k562=='cd19+')


## Remove car/day combinations that aren't in both donors, by t_type
cd4_matches <- plyr::match_df(exh_dt %>% map_day_0 %>% filter(t_type == 'cd4', donor == 2, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day), exh_dt %>% map_day_0 %>% filter(t_type == 'cd4', donor == 1, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day)) %>% arrange(day) #43 matches

cd8_matches <- plyr::match_df(exh_dt %>% map_day_0 %>% filter(t_type == 'cd8', donor == 2, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day), exh_dt %>% map_day_0 %>% filter(t_type == 'cd8', donor == 1, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day)) %>% arrange(day) #40 matches

#filter exh_dt by matched combinations
exh_dt_cd4 <- plyr::match_df(exh_dt_cd4, cd4_matches)
exh_dt_cd8 <- plyr::match_df(exh_dt_cd8, cd8_matches)
```
## Double checking car/day combinations that aren't in both donors
```{r, eval=F}
exh_dt %>% map_day_0 %>% filter(t_type == 'cd4', donor == 1, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day) %>% arrange(day)
#Donor 1 CD4: 43 combinations available (33 BAFF-R and CD28 missing)

exh_dt %>% map_day_0 %>% filter(t_type == 'cd8', donor == 1, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day) %>% arrange(day)
#Donor 1 CD8: 40 combinations available (24 zeta, 33 zeta, BAFF-R, TACI, and KLRG1 missing)

exh_dt %>% map_day_0 %>% filter(t_type == 'cd4', donor == 2, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day) %>% arrange(day)
#Donor 2 CD4: all 45 combinations available

exh_dt %>% map_day_0 %>% filter(t_type == 'cd8', donor == 2, k562=='cd19+') %>% filter(!is.na(event_id)) %>% distinct(car, day) %>% arrange(day)
#Donor 2 CD8: 42 combinations available (33 zeta and KLRG1 missing)
```

## UMAP Functions
```{r}
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map

# for now use all variables in the channel map except cd4/8
umap_vars <- c(paste0(names(channel_map),'_t'))

# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- umap_vars[!umap_vars %in% c('cd_t', 'zombie_t', 'myc_t', 'gfp_t')]
```

## Run UMAP
Scaling this to 200 events per well and checking CAR/condition separation.

```{r, eval=redo_umap_clustering}
umap_cd4_fcs_dt <- run_umap(exh_dt_cd4, 0.005, 15, 200, umap_vars)
umap_cd8_fcs_dt <- run_umap(exh_dt_cd8, 0.005, 15, 200, umap_vars)

fwrite(umap_cd4_fcs_dt, 
  compress='gzip',
  file=file.path(here::here('..','data','exh.sampled.umap_cd4.csv.gz')))

fwrite(umap_cd8_fcs_dt, 
  compress='gzip',
  file=file.path(here::here('..','data','exh.sampled.umap_cd8.csv.gz')))

# sync output back to s3
system('aws s3 sync \\
  --exclude "*" \\
  --include "*.Rdata" \\
  --include "*.csv*" \\
  ~/local-tcsl/data s3://roybal-tcsl/lenti_screen_compiled_data/data')
```

Choosing neighbors == 30 and min_dist == 1e-4. 

## Checking UMAP Param space

Scaling this to 200 events per well and checking CAR/condition separation.

```{r, fig.width=15, fig.height=20}
#CD8
ggumap(umap_cd8_fcs_dt)

#CD4
ggumap(umap_cd4_fcs_dt)
```

### UMAP Color Plots
```{r, fig.width=15, fig.height=10}
#cd8
color_plots(umap_cd8_fcs_dt)

#cd4
color_plots(umap_cd4_fcs_dt)
```

## UMAP Contour Plots

```{r fig.width=7.5, fig.height=20}
#CD8
umap_contour_plots(umap_cd8_fcs_dt)

#CD4
umap_contour_plots(umap_cd4_fcs_dt)
```

## Grouped Cluster Plots 

```{r, fig.width=30, fig.height=15}
#CD8
all_plots(umap_cd8_fcs_dt, 'CD8', dendro=F)

#CD4
all_plots(umap_cd4_fcs_dt, 'CD4', dendro=F)
```

# use umap canned functions
umap_dt <- sample_for_umap(exh_dt, 20)
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != 'cd_t']
sample_for_umap <- function(df, sample_size) {
umap_dt <- diff_dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_size, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
}
cast_for_umap <- function(df) {
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(df,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
return(umap_cast_dt)
}
scale_for_umap <- function(df, umap_vars, censor_negative_min) {
umap_dt_in <- df[, ..umap_vars]
# for points that are very negative, trim the to below the cutoff
umap_dt_in[umap_dt_in < censor_negative_min] <- censor_negative_min
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
return(umap_dt_in)
}
# check scales:
# ggplot(melt(cbind(umap_dt_in, id=1:nrow(umap_dt_in)), id.var='id'),
#        aes(x=value)) +
#     geom_density() +
#     facet_grid(variable~.) +
#     scale_fill_distiller(palette='RdYlBu') +
#     theme_bw()
# use umap canned functions
umap_dt <- sample_for_umap(exh_dt, 20)
umap_cast_dt <- cast_for_umap(umap_dt)
umap_dt_in <- scale_for_umap(umap_cast_dt, umap_vars, censor_negative_min)
umap_vars
channel_map
channel_map <- exh_opt_cd4$channel_map
channel_mo
channel_map
cd4_out
cd4_out
cd8_out
library(data.table)
library(scales)
library(here)
library(flowCore)
library(flowWorkspace)
parent_folder = here::here('..','..')
load_platemaps <- function(exh_dir) {
# load platemap filenames
platemap_paths <- data.table(
filepath= normalizePath(file.path(exh_dir, list.files(
exh_dir,
pattern='.*platemap.csv$',
recursive=TRUE))))
#parse day from file name
platemap_paths[, day := gsub('.*D(\\d+).*', '\\1', filepath)]
# load and merge platemaps
platemaps <- platemap_paths[, fread(file=.BY[[1]]), by=filepath]
# put 0 back into well number (ugh)
platemaps[, well := gsub(' ', '',
gsub('([A-H])(\\d{1})$', '\\1 0\\2', well))]
platemaps[car == 'KRLG1', car := 'KLRG1'][]
return(platemaps)
}
load_fcs <- function(exh_dir) {
exh_fcs_dir <- file.path(exh_dir)
# load fcs filenames
fcs_paths <- data.table(
filepath= normalizePath(file.path(exh_fcs_dir, list.files(
exh_fcs_dir,
pattern='.*fcs',
recursive=TRUE))))
# parse well name
fcs_paths[, well := gsub('.*_([A-H]\\d+).fcs','\\1', filepath)]
fcs_paths[, plate := gsub('.*(\\d+)_[A-H]\\d+.fcs','\\1', filepath)]
fcs_paths[, day := gsub('.*_(\\d+)_\\d+_[A-H]\\d+.fcs','\\1', filepath)]
fcs_dt <- fcs_paths[,
as.data.frame(flowCore::exprs(read.FCS(filepath))),
by=c('well','plate','day')]
# give each event an ID for tracking after melt
fcs_dt[, event_id := .I, by=c('well','plate','day')]
channel_map <- list(
cd="FJComp-379_28 UV-A",
tim3="FJComp-450_50 Violet-A",
gfp="FJComp-515_20 Blue-A",
zombie="FJComp-586_15 Violet-A",
myc="FJComp-610_20 YG-A",
lag3= "FJComp-660_20 Red-A",
pd1= "FJComp-710_50 Violet-A",
cd39="FJComp-780_60 Red-A")
# replace column names
chan_names <- data.table(merge(
names(fcs_dt),
data.table(
marker=names(channel_map),
chan=unlist(channel_map)),
by.x='x', by.y='chan',
all=T))
# fill in original column names
chan_names[is.na(marker), marker := x]
# rename columns and melt
names(fcs_dt) <- chan_names[
names(fcs_dt), marker, on='x']
# merge unmelted with plate map
fcs_dt[, day := as.numeric(day)]
fcs_dt[, plate := as.numeric(plate)]
return(list(fcs_dt= fcs_dt, channel_map= channel_map))
}
load_exh_data <- function(experiment_dir, marker_pos_threshold, max_sample=Inf) {
exh_dir <- file.path(parent_folder, experiment_dir)
platemaps <- load_platemaps(exh_dir)
fcs_out <- load_fcs(exh_dir)
fcs_dt <- fcs_out$fcs_dt
channel_map <- fcs_out$channel_map
rm(fcs_out)
fcs_dt <- merge(
fcs_dt, platemaps,
on=intersect(names(platemaps), names(fcs_dt)), all=TRUE)
# flowJo transform
for (chan_name in c(names(channel_map),
'SSC-A','SSC-W','SSC-H','FSC-A','FSC-H','FSC-W')) {
fcs_dt[, c(paste0(chan_name,'_t')) := flowjo_biexp()(fcs_dt[[chan_name]])]
}
# downsample per well if specified
fcs_dt <- fcs_dt[, .SD[sample(.N, min(c(.N, max_sample)))], by=c('well','plate','day')]
melt_cols <- c(names(channel_map), 'SSC-A','SSC-W','SSC-H','FSC-A','FSC-H','FSC-W')
transformed_vars <- paste0(melt_cols,'_t')
melt_cols <- c(melt_cols, transformed_vars)
fcs_melt_dt <- melt(
fcs_dt,
measure.vars=melt_cols)
marker_thresh_dt <- data.table(
variable= paste0(names(marker_pos_threshold)),
threshold= unlist(marker_pos_threshold))
fcs_melt_dt <- fcs_melt_dt[marker_thresh_dt, on='variable'][, gt_thresh := value > threshold]
fcs_melt_dt[, threshold := NULL]
return(list(fcs_melt_dt= fcs_melt_dt, channel_map=channel_map, melt_cols=melt_cols))
}
# CD4 ======
cd4_marker_pos_threshold <- list(
tim3_t= 666,
gfp_t=1250,
zombie_t=750,
myc_t=1400,
lag3_t= 950,
pd1_t= 1400,
cd39_t= 1100)
#cd4_dir <- "flow/TCSL105 ALL FILES/Exhaust"
#AWS Version:
cd4_dir <- "s3-roybal-tcsl/lenti_screen_compiled_data/data/fcs/tcsl105/exh"
#cd4_out <- load_exh_data(cd4_dir, cd4_marker_pos_threshold)
# CD8 ======
cd8_marker_pos_threshold <- list(
tim3_t= 666,
gfp_t=1500,
zombie_t=750,
myc_t=1400,
lag3_t= 800,
pd1_t= 1400,
cd39_t= 1250)
#cd8_dir <- "flow/2019.06.07 TCSL091 ALL FILES/Exhaust"
#AWS Version:
cd8_dir <- "s3-roybal-tcsl/lenti_screen_compiled_data/data/fcs/tcsl091/exh"
#cd8_out <- load_exh_data(cd8_dir, cd8_marker_pos_threshold)
# exh_dt <- rbind(
#   cd8_out$fcs_melt_dt[, t_type := 'cd8'],
#   cd4_out$fcs_melt_dt[, t_type := 'cd4'])
# cd4_out$fcs_melt_dt <- NULL
# cd8_out$fcs_melt_dt <- NULL
#
# exh_opt_cd4 <- cd4_out
# exh_opt_cd8 <- cd8_out
#
# exh_opt_cd4$marker_thresholds <- cd4_marker_pos_threshold
# exh_opt_cd8$marker_thresholds <- cd8_marker_pos_threshold
#save('exh_opt_cd4', 'exh_opt_cd8', 'exh_dt', file=file.path(here::here('..','data','exh.Rdata')))
# ------
# make a downsampled version for faster plotting and analysis
n_events_per_well <- 2500
cd8_out <- load_exh_data(cd8_dir, cd8_marker_pos_threshold, max_sample=n_events_per_well)
cd4_out <- load_exh_data(cd4_dir, cd4_marker_pos_threshold, max_sample=n_events_per_well)
exh_dt <- rbind(cd8_out$fcs_melt_dt[, t_type := 'cd8'], cd4_out$fcs_melt_dt[, t_type := 'cd4'])
cd4_out$fcs_melt_dt <- NULL
cd8_out$fcs_melt_dt <- NULL
exh_opt_cd4 <- cd4_out
exh_opt_cd8 <- cd8_out
exh_opt_cd4$marker_thresholds <- cd4_marker_pos_threshold
exh_opt_cd8$marker_thresholds <- cd8_marker_pos_threshold
fwrite(exh_dt,
compress='gzip',
file=file.path(here::here('..','data','exh.sampled.csv.gz')))
save(
'exh_opt_cd4',
'exh_opt_cd8',
file=file.path(here::here('..','data','exh.sampled.Rdata')))
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != 'cd_t']
sample_for_umap <- function(df, sample_size) {
umap_dt <- diff_dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_size, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
}
cast_for_umap <- function(df) {
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(df,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
return(umap_cast_dt)
}
scale_for_umap <- function(df, umap_vars, censor_negative_min) {
umap_dt_in <- df[, ..umap_vars]
# for points that are very negative, trim the to below the cutoff
umap_dt_in[umap_dt_in < censor_negative_min] <- censor_negative_min
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
return(umap_dt_in)
}
# check scales:
# ggplot(melt(cbind(umap_dt_in, id=1:nrow(umap_dt_in)), id.var='id'),
#        aes(x=value)) +
#     geom_density() +
#     facet_grid(variable~.) +
#     scale_fill_distiller(palette='RdYlBu') +
#     theme_bw()
# use umap canned functions
umap_dt <- sample_for_umap(exh_dt, 20)
umap_cast_dt <- cast_for_umap(umap_dt)
umap_dt_in <- scale_for_umap(umap_cast_dt, umap_vars, censor_negative_min)
### Run across parameter list
#umap parameter list
min_dist_set <- c(0.0001, 0.005, 0.1)
n_neighbor_set <- c(3,6,15,30)
umap_params <- data.table(expand.grid(min_dist_set, n_neighbor_set))
# run umap via uwot library
umap_out <- umap_params[, {
print(paste0('Running: ',.BY));
as.data.table(umap(umap_dt_in, min_dist=as.numeric(.BY[1]),
n_neighbors=as.numeric(.BY[2]), verbose=F, n_threads=8, n_trees=50))
}, by=names(umap_params)]
library(ggplot2)
library(data.table)
library(scales)
library(RColorBrewer)
library(reticulate)
library(uwot)
library(gridExtra)
library(spatstat)
library(ggplot2)
library(data.table)
library(scales)
library(RColorBrewer)
library(reticulate)
library(uwot)
library(gridExtra)
#library(spatstat)
library(ggdendro)
library(cowplot)
library(tidyverse)
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != 'cd_t']
sample_for_umap <- function(df, sample_size) {
umap_dt <- diff_dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_size, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
}
cast_for_umap <- function(df) {
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(df,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
return(umap_cast_dt)
}
scale_for_umap <- function(df, umap_vars, censor_negative_min) {
umap_dt_in <- df[, ..umap_vars]
# for points that are very negative, trim the to below the cutoff
umap_dt_in[umap_dt_in < censor_negative_min] <- censor_negative_min
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
return(umap_dt_in)
}
# check scales:
# ggplot(melt(cbind(umap_dt_in, id=1:nrow(umap_dt_in)), id.var='id'),
#        aes(x=value)) +
#     geom_density() +
#     facet_grid(variable~.) +
#     scale_fill_distiller(palette='RdYlBu') +
#     theme_bw()
# use umap canned functions
umap_dt <- sample_for_umap(exh_dt, 20)
umap_cast_dt <- cast_for_umap(umap_dt)
umap_dt_in <- scale_for_umap(umap_cast_dt, umap_vars, censor_negative_min)
### Run across parameter list
#umap parameter list
min_dist_set <- c(0.0001, 0.005, 0.1)
n_neighbor_set <- c(3,6,15,30)
umap_params <- data.table(expand.grid(min_dist_set, n_neighbor_set))
# run umap via uwot library
umap_out <- umap_params[, {
print(paste0('Running: ',.BY));
as.data.table(umap(umap_dt_in, min_dist=as.numeric(.BY[1]),
n_neighbors=as.numeric(.BY[2]), verbose=F, n_threads=8, n_trees=50))
}, by=names(umap_params)]
# rename the columns
names(umap_out) <- c('min_dist','n_neighbor','umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
color_points <- ggplot(umap_fcs_dt[car %in% c('CD28','41BB','KLRG1','BAFF-R','Zeta')],
aes(x=umap_1, y=umap_2, color=interaction(car, t_type))) +
geom_point(size=0.1, alpha=0.1) +
guides(colour = guide_legend(override.aes = list(alpha=1, size=3))) +
facet_grid(min_dist~n_neighbor) +
theme_bw()
color_density <- ggplot(umap_fcs_dt, aes(x=umap_1, y=umap_2)) +
geom_hex(bins = 70) +
scale_fill_continuous(
type = "viridis", limits=c(0,30), oob=scales::squish) +
facet_grid(min_dist~n_neighbor) +
theme_bw()
grid.arrange(color_points, color_density, ncol=2)
grid.arrange(color_points, color_density, ncol=2)
here:here()
here::here()
here::here('py')
here::here('py/leiden_alg.py')
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, channel_map) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
n_neighbors=chosen_n_neighbor, verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
umap_nn <- cbind(1:nrow(umap_fcs_dt),
nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors, edge_weights)
umap_fcs_dt[, cluster := factor(clust_membership+1)]
}
run_umap(exh_dt, 15, 0.1, exh_opt_cd4$channel_map)
exh_opt_cd4$channel_map
dt=exh_dt; chosen_dist=15; chosen_n_neighbor=0.1; sample_n=50; channel_map=exh_opt_cd4$channel_map;
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
umap_vars
umap_vars
umap_cast_dt
channel_map
umap_vars <- c('tim3','lag3','cd39','pd1')
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
umap_vars <- c('tim3_t','lag3_t','cd39_t','pd1_t')
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
n_neighbors=chosen_n_neighbor, verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
chosen_n_neighbor
chosen_dist
dt=exh_dt; chosen_dist=0.1; chosen_n_neighbor=15; sample_n=50; channel_map=exh_opt_cd4$channel_map;
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
n_neighbors=chosen_n_neighbor, verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
umap_nn <- cbind(1:nrow(umap_fcs_dt),
nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
?nnwhich
source_python(here::here('py/leiden_clust.py'))
source_python(here::here('py/leiden_clust.py'))
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors, edge_weights)
clust_membership
nearest_neighbors
edge_weights
clust_membership
clust_membership <- leiden_clust(nearest_neighbors, edge_weights)
clust_membership
repl_python()

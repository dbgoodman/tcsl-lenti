}
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != c('cd_t', 'zombie_t', 'myc_t', 'gfp_t')]
sample_for_umap <- function(df, sample_size) {
umap_dt <- diff_dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_size, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
}
cast_for_umap <- function(df) {
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(df,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
return(umap_cast_dt)
}
scale_for_umap <- function(df, umap_vars, censor_negative_min) {
umap_dt_in <- df[, ..umap_vars]
# for points that are very negative, trim the to below the cutoff
umap_dt_in[umap_dt_in < censor_negative_min] <- censor_negative_min
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
return(umap_dt_in)
}
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
umap_vars <- c("tim3_t","lag3_t","cd39_t","pd1_t" )
umap_cd4_fcs_dt <- run_umap(exh_dt[t_type == 'cd4'], 0.005, 15, 2500, umap_vars)
umap_vars <- c("tim3_t","lag3_t","cd39_t","pd1_t" )
umap_vars
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != c('cd_t', 'zombie_t', 'myc_t', 'gfp_t')]
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != c('cd_t', 'zombie_t', 'myc_t', 'gfp_t')]
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
umap_vars
umap_vars
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[umap_vars != c('cd_t', 'zombie_t', 'myc_t', 'gfp_t')]
umap_vars
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[!(umap_vars %in% c('cd_t', 'zombie_t', 'myc_t', 'gfp_t'))]
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[!(umap_vars %in% c('cd_t', 'zombie_t', 'myc_t', 'gfp_t'))]
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
umap_cd4_fcs_dt <- run_umap(exh_dt[t_type == 'cd4'], 0.005, 15, 2500, umap_vars)
umap_vars
exh_dt
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[!(umap_vars %in% c('cd_t', 'zombie_t', 'myc_t', 'gfp_t'))]
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
print(names(umap_cast_dt))
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
umap_cd4_fcs_dt <- run_umap(exh_dt[t_type == 'cd4'], 0.005, 15, 2500, umap_vars)
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[!(umap_vars %in% c('cd_t', 'zombie_t', 'myc_t', 'gfp_t'))]
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value')
print(names(umap_cast_dt))
umap_dt_in <- umap_cast_dt[, umap_vars, with=F]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
umap_cd4_fcs_dt <- run_umap(exh_dt[t_type == 'cd4'], 0.005, 15, 2500, umap_vars)
#grab channel map from cd4 data (cd4/8 are the same)
channel_map <- exh_opt_cd4$channel_map
# for now use all variables in the channel map except cd4/8
# removing zombie, cd_t, myc_t, gfp_t
umap_vars <- c(paste0(names(channel_map),'_t'))
umap_vars <- umap_vars[!(umap_vars %in% c('cd_t', 'zombie_t', 'myc_t', 'gfp_t'))]
run_umap <- function(dt, chosen_dist, chosen_n_neighbor, sample_n, umap_vars,
chosen_learning_rate=0.1) {
umap_dt <- dt[!is.na(event_id),
.SD[event_id %in% sample(unique(event_id),
min(sample_n, length(unique(event_id))))],
by=c('well', 'plate', 'day')]
#grab channel map from cd4 data (cd4/8 are the same)
#channel_map <- diff_opt_cd4$channel_map
# for now use all variables in the channel map
#umap_vars <- c(paste0(names(channel_map),'_t'))
#cast it so variables are columns and
#subset sample umap data on variables
umap_cast_dt <- data.table(dcast(umap_dt,
event_id + well + plate + day + t_type ~ variable,
value.var='value'))
umap_dt_in <- umap_cast_dt[, ..umap_vars]
# scale each input column
umap_dt_in[ ,
(names(umap_dt_in)) := lapply(.SD, scale), .SDcols = names(umap_dt_in)]
# run umap via uwot library
umap_out <- umap(umap_dt_in, min_dist=chosen_dist,
learning_rate=chosen_learning_rate,
n_sgd_threads=1,
n_neighbors=chosen_n_neighbor,
verbose=T, n_threads=8, n_trees=50,
ret_nn=T)
# nearest neighbors in original space
nearest_neighbors <- umap_out$nn$euclidean$idx
neighbor_dist <- umap_out$nn$euclidean$dist
edge_weights <- scales::rescale(-neighbor_dist, to=c(0,1))
edge_weights <- edge_weights - min(edge_weights)
umap_out <- data.table(umap_out$embedding)
#nearest neighbors in embedding
# umap_nn <- cbind(1:nrow(umap_fcs_dt),
#     nnwhich(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_nd <- cbind(rep(0, nrow(umap_fcs_dt)),
#     nndist(umap_fcs_dt[, list(umap_1, umap_2)], k=c(1:3)))
# umap_ew <- scales::rescale(-umap_nd, to=c(0,1))
# umap_ew <- umap_ew - min(umap_ew)
# rename the columns
names(umap_out) <- c('umap_1','umap_2')
# add the umap output to the input dt
umap_fcs_dt <- cbind(umap_cast_dt[, 1:length(names(umap_cast_dt))], umap_out)
umap_fcs_dt[, id := 1:.N]
# add back the annotations
umap_fcs_dt <- unique(umap_dt[,
.(donor, car, k562, t_type, day, well, event_id)])[
umap_fcs_dt, on=.(t_type,well,day,event_id)]
print(edge_weights)
source_python(here::here('py/leiden_clust.py'))
clust_membership <- leiden_clust(nearest_neighbors,
edge_weights=scales::rescale(-neighbor_dist, to=c(0,1)))
umap_fcs_dt[, cluster := factor(clust_membership+1)]
return(umap_fcs_dt)
}
umap_cd4_fcs_dt <- run_umap(exh_dt[t_type == 'cd4'], 0.005, 15, 2500, umap_vars)
# umap_cd4_fcs_dt <- fread(
#   file.path(
#     here::here('..','data','diff.sampled.umap_cd4.csv.gz')))
# umap_cd8_fcs_dt[, cluster := factor(cluster)]
umap_cd4_cluster_dt <- umap_cd4_fcs_dt[, list(
mean_umap_1= mean(umap_1),
mean_umap_2= mean(umap_2),
size= .N), by=cluster]
# whole plot
ggplot() +
geom_point(data=umap_cd4_cluster_dt,
aes(x=umap_1, y=umap_2, color=cluster), size=0.2, alpha=0.2) +
geom_label(data=umap_cd8_cluster_dt, aes(
x=mean_umap_1, y=mean_umap_2,
label=paste(cluster,size,sep='\n'),
color=cluster), alpha=0.3) +
theme_minimal()
ggplot() +
geom_point(data=umap_cd4_cluster_dt,
aes(x=umap_1, y=umap_2, color=cluster), size=0.2, alpha=0.2) +
geom_label(data=umap_cd4_cluster_dt, aes(
x=mean_umap_1, y=mean_umap_2,
label=paste(cluster,size,sep='\n'),
color=cluster), alpha=0.3) +
theme_minimal()
umap_cd4_cluster_dt <- umap_cd4_fcs_dt[, list(
mean_umap_1= mean(umap_1),
mean_umap_2= mean(umap_2),
size= .N), by=cluster]
ggplot() +
geom_point(data=umap_cd4_fcs_dt,
aes(x=umap_1, y=umap_2, color=cluster), size=0.2, alpha=0.2) +
geom_label(data=umap_cd4_cluster_dt, aes(
x=mean_umap_1, y=mean_umap_2,
label=paste(cluster,size,sep='\n'),
color=cluster), alpha=0.3) +
theme_minimal()
umap_cd4_fcs_dt <- run_umap(exh_dt[t_type == 'cd4'], 0.005, 5, 100, umap_vars)
